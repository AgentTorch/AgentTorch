
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
        <link rel="prev" href="../../contributing/">
      
      
        <link rel="next" href="../config_api/">
      
      
        
      
      
      <link rel="icon" href="../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.7.1">
    
    
      
        <title>Creating a Model - AgentTorch</title>
      
    
    
      <link rel="stylesheet" href="../../assets/stylesheets/main.484c7ddc.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
    <script>__md_scope=new URL("../..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
  </head>
  
  
    <body dir="ltr">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#predator-prey-model" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href="../.." title="AgentTorch" class="md-header__button md-logo" aria-label="AgentTorch" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            AgentTorch
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Creating a Model
            
          </span>
        </div>
      </div>
    </div>
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      
      
        <label class="md-header__button md-icon" for="__search">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        </label>
        <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
      
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../.." title="AgentTorch" class="md-nav__button md-logo" aria-label="AgentTorch" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>

    </a>
    AgentTorch
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../.." class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Home
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../install/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Installation Guide
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../architecture/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Framework Architecture
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../contributing/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Contributing Guide
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
    
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--active md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_5" checked>
        
          
          <label class="md-nav__link" for="__nav_5" id="__nav_5_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    
  
    Tutorials
  

    
  </span>
  
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_5_label" aria-expanded="true">
          <label class="md-nav__title" for="__nav_5">
            <span class="md-nav__icon md-icon"></span>
            
  
    Tutorials
  

          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
    
  
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" type="checkbox" id="__toc">
      
      
        
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          
  
  
  <span class="md-ellipsis">
    
  
    Creating a Model
  

    
  </span>
  
  

          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="./" class="md-nav__link md-nav__link--active">
        
  
  
  <span class="md-ellipsis">
    
  
    Creating a Model
  

    
  </span>
  
  

      </a>
      
        

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#model-overview" class="md-nav__link">
    <span class="md-ellipsis">
      
        Model Overview
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#state-environment-agents-and-objects" class="md-nav__link">
    <span class="md-ellipsis">
      
        State: Environment, Agents, and Objects
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="State: Environment, Agents, and Objects">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#environment" class="md-nav__link">
    <span class="md-ellipsis">
      
        Environment
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#agents" class="md-nav__link">
    <span class="md-ellipsis">
      
        Agents
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Agents">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#predator" class="md-nav__link">
    <span class="md-ellipsis">
      
        Predator
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#prey" class="md-nav__link">
    <span class="md-ellipsis">
      
        Prey
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#objects" class="md-nav__link">
    <span class="md-ellipsis">
      
        Objects
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Objects">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#grass" class="md-nav__link">
    <span class="md-ellipsis">
      
        Grass
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#network" class="md-nav__link">
    <span class="md-ellipsis">
      
        Network
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#substeps" class="md-nav__link">
    <span class="md-ellipsis">
      
        Substeps
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Substeps">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#move" class="md-nav__link">
    <span class="md-ellipsis">
      
        Move
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#eat" class="md-nav__link">
    <span class="md-ellipsis">
      
        Eat
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#hunt" class="md-nav__link">
    <span class="md-ellipsis">
      
        Hunt
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#grow" class="md-nav__link">
    <span class="md-ellipsis">
      
        Grow
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#execution-configuration-registry-and-runner" class="md-nav__link">
    <span class="md-ellipsis">
      
        Execution: Configuration, Registry, and Runner
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Execution: Configuration, Registry, and Runner">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#configuration" class="md-nav__link">
    <span class="md-ellipsis">
      
        Configuration
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#registry-and-runner" class="md-nav__link">
    <span class="md-ellipsis">
      
        Registry and Runner
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#visualization" class="md-nav__link">
    <span class="md-ellipsis">
      
        Visualization
      
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../config_api/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Using the Config API
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../processing-a-population/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Customizing the Population
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../configure-behavior/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Prompting LLM as LPM agents
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../integrating-with-beckn/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    From Simulation to Reality
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../creating-archetypes/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Benchmark: Modeling with Archetypes
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../compare-llm-performance/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Benchmark: Sensitivity to Agent Behaviors
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../differentiable-discrete-sampling/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Differentiable Discrete Sampling
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#model-overview" class="md-nav__link">
    <span class="md-ellipsis">
      
        Model Overview
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#state-environment-agents-and-objects" class="md-nav__link">
    <span class="md-ellipsis">
      
        State: Environment, Agents, and Objects
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="State: Environment, Agents, and Objects">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#environment" class="md-nav__link">
    <span class="md-ellipsis">
      
        Environment
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#agents" class="md-nav__link">
    <span class="md-ellipsis">
      
        Agents
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Agents">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#predator" class="md-nav__link">
    <span class="md-ellipsis">
      
        Predator
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#prey" class="md-nav__link">
    <span class="md-ellipsis">
      
        Prey
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#objects" class="md-nav__link">
    <span class="md-ellipsis">
      
        Objects
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Objects">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#grass" class="md-nav__link">
    <span class="md-ellipsis">
      
        Grass
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#network" class="md-nav__link">
    <span class="md-ellipsis">
      
        Network
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#substeps" class="md-nav__link">
    <span class="md-ellipsis">
      
        Substeps
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Substeps">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#move" class="md-nav__link">
    <span class="md-ellipsis">
      
        Move
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#eat" class="md-nav__link">
    <span class="md-ellipsis">
      
        Eat
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#hunt" class="md-nav__link">
    <span class="md-ellipsis">
      
        Hunt
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#grow" class="md-nav__link">
    <span class="md-ellipsis">
      
        Grow
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#execution-configuration-registry-and-runner" class="md-nav__link">
    <span class="md-ellipsis">
      
        Execution: Configuration, Registry, and Runner
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Execution: Configuration, Registry, and Runner">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#configuration" class="md-nav__link">
    <span class="md-ellipsis">
      
        Configuration
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#registry-and-runner" class="md-nav__link">
    <span class="md-ellipsis">
      
        Registry and Runner
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#visualization" class="md-nav__link">
    <span class="md-ellipsis">
      
        Visualization
      
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              
              <article class="md-content__inner md-typeset">
                
                  



<h1 id="predator-prey-model">Predator-Prey Model</h1>
<details>
  <summary>Imports</summary>


<pre><code class="language-python"># import agent-torch

import os
import sys
module_path = os.path.abspath(os.path.join('../../../agent_torch'))
if module_path not in sys.path:
    sys.path.append(module_path)

from AgentTorch import Runner, Registry
from AgentTorch.substep import SubstepObservation, SubstepAction, SubstepTransition
from AgentTorch.helpers import get_by_path, read_config, read_from_file, grid_network
</code></pre>



<pre><code class="language-python"># import all external libraries that we need.

import math
import torch
import re
import random
import argparse
import numpy as np
import torch.nn as nn
import networkx as nx
import osmnx as ox
from tqdm import trange
</code></pre>



<pre><code class="language-python"># define the helper functions we need.

def get_var(state, var):
  &quot;&quot;&quot;
    Retrieves a value from the current state of the model.
  &quot;&quot;&quot;
  return get_by_path(state, re.split('/', var))
</code></pre>


</details>

<blockquote>
<p>The complete code for this model can be found
<a href="https://github.com/agenttorch/agenttorch/blob/master/models/predator_prey">here</a>.
The architecture of the AgentTorch framework, which explains some key
concepts, can be found <a href="../../architecture/">here</a>.</p>
</blockquote>
<p>This guide walks you through creating a custom predator-prey model using the
AgentTorch framework. This model will simulate an ecosystem consisting of
predators, prey and grass: predators eat prey, and prey eat grass.</p>
<p>The model's parameters, rules and configuration are passed to AgentTorch, which
iteratively simulates the model, allowing you to optimize its learnable
parameters, while also modelling the simulation in real time. AgentTorch's
Python API is based on PyTorch, which enhances its performance on GPUs.</p>
<p>The following sections detail:</p>
<ul>
<li>an overview of the model's rules and parameters.</li>
<li>the properties of all entities stored in the model's state.</li>
<li>the substeps that observe, simulate and modify the state for each agent.</li>
<li>the code required to run the simulation using <code>agent-torch</code>.</li>
<li>plotting the state's trajectory using <code>matplotlib</code>.</li>
</ul>
<h2 id="model-overview">Model Overview</h2>
<p>The following are configurable parameters of the model:</p>
<ul>
<li>a $n \times m$ grid, with $p$ predators and $q$ prey to start with.</li>
<li>grass can grown on any of the $n \cdot m$ squares in the grid.</li>
</ul>
<p>The rules followed by the simulated interactions are configured as follows:</p>
<ul>
<li>predators can eat only prey, and prey can eat only grass.</li>
<li>grass grows back once eaten after a certain number of steps.</li>
<li>upon consuming food, the energy of the consumer increases.</li>
<li>movement happens randomly, to any neighbouring square in the grid.</li>
<li>each move reduces the energy of the entity by a fixed amount.</li>
</ul>
<p>These parameters and rules, along with the properties of the entities (detailed
below) in the simulation are defined in a configuration file, and passed on to
the model.</p>
<h2 id="state-environment-agents-and-objects">State: Environment, Agents, and Objects</h2>
<p>The model's state consists of a list of properties of the simulated environment,
and the agents and objects situated in that simulation. For this model, the:</p>
<h3 id="environment">Environment</h3>
<p>The environment will have only one property: the size of the two-dimensional
grid in which the predators and prey wander, defined like so:</p>
<pre><code class="language-yaml">environment:
  bounds: (max_x, max_y) # tuple of integers
</code></pre>
<h3 id="agents">Agents</h3>
<p>This model has two agents: predator, and prey.</p>
<h4 id="predator">Predator</h4>
<p>The predator agent is defined like so:</p>
<pre><code class="language-yaml">predator:
  coordinates: (x, y) # tuple of integers
  energy: float
  stride_work: float
</code></pre>
<p>The <code>coordinates</code> property depicts the current position of the predator in the
two-dimensional grid. It is initialized from a CSV file that contains a list of
randomly generated coordinates for all 40 predators.</p>
<p>The <code>energy</code> property stores the current amount of energy possessed by the
predator. Initially, this property is set to a random number between 30 and 100.</p>
<p>The <code>stride_work</code> property is a static, but learnable property that stores the
amount of energy to deduct from a predator for one step in any direction on the
grid.</p>
<h4 id="prey">Prey</h4>
<p>The prey agent is identical to the predator agent, and has one additional
property: <code>nutritional_value</code>.</p>
<pre><code class="language-yaml">prey:
  coordinates: (x, y) # tuple of integers
  energy: float
  stride_work: float
  nutritional_value: float
</code></pre>
<p>The <code>nutritional_value</code> property is a static but learnable property that stores
the amount of energy gained by a predator when it consumes a single prey entity.</p>
<h3 id="objects">Objects</h3>
<p>This model has only one agent: grass.</p>
<h4 id="grass">Grass</h4>
<p>The grass entity is defined as follows:</p>
<pre><code class="language-yaml">grass:
  coordinates: (x, y)
  growth_stage: 0|1
  growth_countdown: float
  regrowth_time: float
  nutritional_value: float
</code></pre>
<p>The <code>coordinates</code> property depicts the current position of the predator in the
two-dimensional grid. It is initialized from a CSV file that contains a list of
all 1600 coordinates.</p>
<p>The <code>growth_stage</code> property stores the current growth stage of the grass: 0
means it is growing, and 1 means it is fully grown.</p>
<p>The <code>growth_countdown</code> property stores the number of steps after which the grass
becomes fully grown. The <code>regrowth_time</code> property is static and learnable, and
stores the max value of the countdown property.</p>
<p>The <code>nutritional_value</code> property is a static but learnable property that stores
the amount of energy gained by a predator when it consumes a single prey entity.</p>
<h2 id="network">Network</h2>
<p>The model makes use of the adjacency matrix of a two-dimensional grid filled
with predator and prey to simulate the movement of those entities.</p>
<pre><code class="language-yaml">network:
  agent_agent:
    grid: [predator, prey]
</code></pre>
<h2 id="substeps">Substeps</h2>
<p>Each substep is a <code>torch.nn.ModuleDict</code> that takes an input state, and produces
an updated state as output. A substep consists of three phases:</p>
<ol>
<li>Observation (retrieving relevant information from the state)</li>
<li>Policy/Action (deciding on the course of action as per the observations)</li>
<li>Transition (randomizing and updating the state according to the action)</li>
</ol>
<p>This model consists of four substeps: <code>move</code>, <code>eat_grass</code>, <code>hunt_prey</code>, and
<code>grow_grass</code>.</p>
<details>
  <summary>Helper functions</summary>


<pre><code class="language-python"># define all the helper functions we need.

def get_neighbors(pos, adj_grid, bounds):
  &quot;&quot;&quot;
    Returns a list of neighbours for each position passed in the given
    `pos` tensor, using the adjacency matrix passed in `adj_grid`.
  &quot;&quot;&quot;
  x, y = pos
  max_x, max_y = bounds

  # calculate the node number from the x, y coordinate.
  # each item (i, j) in the adjacency matrix, if 1 depicts
  # that i is connected to j and vice versa.
  node = (max_y * x) + y
  conn = adj_grid[node]

  neighbors = []
  for idx, cell in enumerate(conn):
    # if connected, calculate the (x, y) coords of the other
    # node and add it to the list of neighbors.
    if cell == 1:
      c = (int) (idx % max_y)
      r = math.floor((idx - c) / max_y)

      neighbors.append(
        [torch.tensor(r), torch.tensor(c)]
      )

  return torch.tensor(neighbors)

# define a function to retrieve the input required
def get_find_neighbors_input(state, input_variables):
    bounds = get_var(state, input_variables['bounds'])
    adj_grid = get_var(state, input_variables['adj_grid'])
    positions = get_var(state, input_variables['positions'])

    return bounds, adj_grid, positions

def get_decide_movement_input(state, input_variables):
    positions = get_var(state, input_variables['positions'])
    energy = get_var(state, input_variables['energy'])

    return positions, energy

def get_update_positions_input(state, input_variables):
    prey_energy = get_var(state, input_variables['prey_energy'])
    pred_energy = get_var(state, input_variables['pred_energy'])
    prey_work = get_var(state, input_variables['prey_work'])
    pred_work = get_var(state, input_variables['pred_work'])

    return prey_energy, pred_energy, prey_work, pred_work

def get_find_eatable_grass_input(state, input_variables):
    bounds = get_var(state, input_variables['bounds'])
    positions = get_var(state, input_variables['positions'])
    grass_growth = get_var(state, input_variables['grass_growth'])

    return bounds, positions, grass_growth

def get_eat_grass_input(state, input_variables):
    bounds = get_var(state, input_variables['bounds'])
    prey_pos = get_var(state, input_variables['prey_pos'])
    energy = get_var(state, input_variables['energy'])
    nutrition = get_var(state, input_variables['nutrition'])
    grass_growth = get_var(state, input_variables['grass_growth'])
    growth_countdown = get_var(state, input_variables['growth_countdown'])
    regrowth_time = get_var(state, input_variables['regrowth_time'])

    return bounds, prey_pos, energy, nutrition, grass_growth, growth_countdown, regrowth_time

def get_find_targets_input(state, input_variables):
    prey_pos = get_var(state, input_variables['prey_pos'])
    pred_pos = get_var(state, input_variables['pred_pos'])

    return prey_pos, pred_pos

def get_hunt_prey_input(state, input_variables):
    prey_pos = get_var(state, input_variables['prey_pos'])
    prey_energy = get_var(state, input_variables['prey_energy'])
    pred_pos = get_var(state, input_variables['pred_pos'])
    pred_energy = get_var(state, input_variables['pred_energy'])
    nutrition = get_var(state, input_variables['nutritional_value'])

    return prey_pos, prey_energy, pred_pos, pred_energy, nutrition

def get_grow_grass_input(state, input_variables):
    grass_growth = get_var(state, input_variables['grass_growth'])
    growth_countdown = get_var(state, input_variables['growth_countdown'])

    return grass_growth, growth_countdown
</code></pre>


</details>

<h3 id="move">Move</h3>
<p>First, we <strong>observe</strong> the state, and find a list of neighboring positions for
each of the predators/prey currently alive.</p>
<pre><code class="language-python">@Registry.register_substep(&quot;find_neighbors&quot;, &quot;observation&quot;)
class FindNeighbors(SubstepObservation):
  def __init__(self, *args, **kwargs):
    super().__init__(*args, **kwargs)

  def forward(self, state):
    bounds, adj_grid, positions = get_find_neighbors_input(state, self.input_variables)

    # for each agent (prey/predator), find the adjacent cells and pass
    # them on to the policy class.
    possible_neighbors = []
    for pos in positions:
      possible_neighbors.append(
        get_neighbors(pos, adj_grid, bounds)
      )

    return { self.output_variables[0]: possible_neighbors }
</code></pre>
<p>Then, we decide the course of <strong>action</strong>: to move each entity to a random
neighboring position, only if they have the energy to do so.</p>
<pre><code class="language-python">@Registry.register_substep(&quot;decide_movement&quot;, &quot;policy&quot;)
class DecideMovement(SubstepAction):
  def __init__(self, *args, **kwargs):
    super().__init__(*args, **kwargs)

  def forward(self, state, observations):
    positions, energy = get_decide_movement_input(state, self.input_variables)
    possible_neighbors = observations['possible_neighbors']

    # randomly choose the next position of the agent. if the agent
    # has non-positive energy, don't let it move.
    next_positions = []
    for idx, pos in enumerate(positions):
      next_positions.append(
        random.choice(possible_neighbors[idx]) if energy[idx] &gt; 0 else pos
      )

    return { self.output_variables[0]: torch.stack(next_positions, dim=0) }
</code></pre>
<p>Lastly, we <strong>update</strong> the state, with the new positions of the entities, and
reduce the energy of each entity by the value of the <code>stride_work</code> learnable
parameter.</p>
<pre><code class="language-python">@Registry.register_substep(&quot;update_positions&quot;, &quot;transition&quot;)
class UpdatePositions(SubstepTransition):
  def __init__(self, *args, **kwargs):
    super().__init__(*args, **kwargs)

  def forward(self, state, action):
    prey_energy, pred_energy, prey_work, pred_work = get_update_positions_input(state, self.input_variables)

    # reduce the energy of the agent by the work required by them
    # to take one step.
    prey_energy = prey_energy + torch.full(prey_energy.shape, -1 * (prey_work.item()))
    pred_energy = pred_energy + torch.full(pred_energy.shape, -1 * (pred_work.item()))

    return {
      self.output_variables[0]: action['prey']['next_positions'],
      self.output_variables[1]: prey_energy,
      self.output_variables[2]: action['predator']['next_positions'],
      self.output_variables[3]: pred_energy
    }
</code></pre>
<h3 id="eat">Eat</h3>
<p>First, <strong>decide</strong> which grass is fit to be consumed by the prey.</p>
<pre><code class="language-python">@Registry.register_substep(&quot;find_eatable_grass&quot;, &quot;policy&quot;)
class FindEatableGrass(SubstepAction):
  def __init__(self, *args, **kwargs):
    super().__init__(*args, **kwargs)

  def forward(self, state, observations):
    bounds, positions, grass_growth = get_find_eatable_grass_input(state, self.input_variables)

    # if the grass is fully grown, i.e., its growth_stage is equal to
    # 1, then it can be consumed by prey.
    eatable_grass_positions = []
    max_x, max_y = bounds
    for pos in positions:
      x, y = pos
      node = (max_y * x) + y
      if grass_growth[node] == 1:
        eatable_grass_positions.append(pos)

    # pass on the consumable grass positions to the transition class.
    return { self.output_variables[0]: eatable_grass_positions }
</code></pre>
<p>Then, simulate the consumption of the grass, and <strong>update</strong> the growth stage,
growth countdown, and energies of the grass and prey respectively.</p>
<pre><code class="language-python">@Registry.register_substep(&quot;eat_grass&quot;, &quot;transition&quot;)
class EatGrass(SubstepTransition):
  def __init__(self, *args, **kwargs):
    super().__init__(*args, **kwargs)

  def forward(self, state, action):
    bounds, prey_pos, energy, nutrition, grass_growth, growth_countdown, regrowth_time = get_eat_grass_input(state, self.input_variables)

    # if no grass can be eaten, skip modifying the state.
    if len(action['prey']['eatable_grass_positions']) &lt; 1:
      return {}

    eatable_grass_positions = torch.stack(action['prey']['eatable_grass_positions'], dim=0)
    max_x, max_y = bounds
    energy_mask = None
    grass_mask, countdown_mask = torch.zeros(*grass_growth.shape), torch.zeros(*growth_countdown.shape)

    # for each consumable grass, figure out if any prey agent is at
    # that position. if yes, then mark that position in the mask as
    # true. also, for all the grass that will be consumed, reset the
    # growth stage.
    for pos in eatable_grass_positions:
      x, y = pos
      node = (max_y * x) + y

      # TODO: make sure dead prey cannot eat
      e_m = (pos == prey_pos).all(dim=1).view(-1, 1)
      if energy_mask is None:
        energy_mask = e_m
      else:
        energy_mask = e_m + energy_mask

      grass_mask[node] = -1
      countdown_mask[node] = regrowth_time - growth_countdown[node]

    # energy + nutrition adds the `nutrition` tensor to all elements in
    # the energy tensor. the (~energy_mask) ensures that the change is
    # undone for those prey that did not consume grass.
    energy = energy_mask*(energy + nutrition) + (~energy_mask)*energy

    # these masks use simple addition to make changes to the original
    # values of the tensors.
    grass_growth = grass_growth + grass_mask
    growth_countdown = growth_countdown + countdown_mask

    return {
      self.output_variables[0]: energy,
      self.output_variables[1]: grass_growth,
      self.output_variables[2]: growth_countdown
    }
</code></pre>
<h3 id="hunt">Hunt</h3>
<p>First, <strong>decide</strong> which prey are to be eaten.</p>
<pre><code class="language-python">@Registry.register_substep(&quot;find_targets&quot;, &quot;policy&quot;)
class FindTargets(SubstepAction):
  def __init__(self, *args, **kwargs):
    super().__init__(*args, **kwargs)

  def forward(self, state, observations):
    prey_pos, pred_pos = get_find_targets_input(state, self.input_variables)

    # if there are any prey at the same position as a predator,
    # add them to the list of targets to kill.
    target_positions = []
    for pos in pred_pos:
      if (pos == prey_pos).all(-1).any(-1) == True:
        target_positions.append(pos)

    # pass that list of targets to the transition class.
    return { self.output_variables[0]: target_positions }
</code></pre>
<p>Then, <strong>update</strong> the energies of both the prey and the predator.</p>
<pre><code class="language-python">@Registry.register_substep(&quot;hunt_prey&quot;, &quot;transition&quot;)
class HuntPrey(SubstepTransition):
  def __init__(self, *args, **kwargs):
    super().__init__(*args, **kwargs)

  def forward(self, state, action):
    prey_pos, prey_energy, pred_pos, pred_energy, nutrition = get_hunt_prey_input(state, self.input_variables)

    # if there are no targets, skip the state modifications.
    if len(action['predator']['target_positions']) &lt; 1:
      return {}

    target_positions = torch.stack(action['predator']['target_positions'], dim=0)

    # these are masks similars to the ones in `substeps/eat.py`.
    prey_energy_mask = None
    pred_energy_mask = None
    for pos in target_positions:
      pye_m = (pos == prey_pos).all(dim=1).view(-1, 1)
      if prey_energy_mask is None:
        prey_energy_mask = pye_m
      else:
        prey_energy_mask = prey_energy_mask + pye_m

      pde_m = (pos == pred_pos).all(dim=1).view(-1, 1)
      if pred_energy_mask is None:
        pred_energy_mask = pde_m
      else:
        pred_energy_mask = pred_energy_mask + pde_m

    # any prey that is marked for death should be given zero energy.
    prey_energy = prey_energy_mask*0 + (~prey_energy_mask)*prey_energy
    # any predator that has hunted should be given additional energy.
    pred_energy = pred_energy_mask*(pred_energy + nutrition) + (~pred_energy_mask)*pred_energy

    return {
      self.output_variables[0]: prey_energy,
      self.output_variables[1]: pred_energy
    }
</code></pre>
<h3 id="grow">Grow</h3>
<p>In this substep, we simply <strong>update</strong> the growth countdown of every grass
object, and if the countdown has elapsed, we update the growth stage to <code>1</code>.</p>
<pre><code class="language-python">@Registry.register_substep(&quot;grow_grass&quot;, &quot;transition&quot;)
class GrowGrass(SubstepTransition):
  def __init__(self, *args, **kwargs):
    super().__init__(*args, **kwargs)

  def forward(self, state, action):
    grass_growth, growth_countdown = get_grow_grass_input(state, self.input_variables)

    # reduce all countdowns by 1 unit of time.
    growth_countdown_mask = torch.full(growth_countdown.shape, -1)
    growth_countdown = growth_countdown + growth_countdown_mask

    # if the countdown has reached zero, set the growth stage to 1,
    # otherwise, keep it zero.
    grass_growth_mask = (growth_countdown &lt;= 0).all(dim=1)
    grass_growth = grass_growth_mask*(1) + (~grass_growth_mask)*(0)

    return {
      self.output_variables[0]: grass_growth.view(-1, 1),
      self.output_variables[1]: growth_countdown
    }
</code></pre>
<h2 id="execution-configuration-registry-and-runner">Execution: Configuration, Registry, and Runner</h2>
<h3 id="configuration">Configuration</h3>
<p>There are several parts to the configuration, written in a file traditionally
called <code>config.yaml</code>. The following is a brief overview of all the major
sections in the configuration file.</p>
<pre><code class="language-yaml"># config.yaml
# configuration for the predator-prey model.

metadata:
  # device type, episode count, data files, etc.

state:
  environment:
    # variables/properties of the simulated enviroment.

  agents:
    # a list of agents in the simulation, and their properties.
    # each property must be initialized by specifying a value
    # or a generator function, and have a fixed tensor shape.

  objects:
    # a list of objects, similar to the agents list.

  network:
    # a list of interaction models for the simulation.
    # could be a grid, or a directed graph, etc.

substeps:
  # a list of substeps
  # each substep has a list of agents to run that substep for
  # as well as the function, input and output variables for each
  # part of that substep (observation, policy and transition)
</code></pre>
<p>The following is an example of defining a property in the configuration.</p>
<pre><code class="language-yaml">bounds:
  name: 'Bounds'
  learnable: false
  shape: 2
  dtype: 'int'
  value:
    - ${simulation_metadata.max_x} # you can refer to other parts of the config using
    - ${simulation_metadata.max_y} # the template syntax, i.e., ${path.to.config.value}
  initialization_function: null
</code></pre>
<p>Notice that to define one single property, we mentioned:</p>
<ul>
<li>the name of the property, here, <code>'bounds'</code>.</li>
<li>whether or not the property is learnable, in this case, <code>false</code>.</li>
<li>the shape of the tensor that stores the values, in this case, it is a
  one-dimensional array of two elements: <code>(max_x, max_y)</code>.</li>
<li>the value of the property, either by directly providing the value or by
  providing a function that returns the value.</li>
</ul>
<p>The full configuration for the predator-prey model can be found
<a href="../config.yaml">here</a>.</p>
<pre><code class="language-python"># define helper functions used in the configuration

@Registry.register_helper('map', 'network')
def map_network(params):
  coordinates = (40.78264403323726, -73.96559413265355) # central park
  distance = 550

  graph = ox.graph_from_point(coordinates, dist=distance, simplify=True, network_type=&quot;walk&quot;)
  adjacency_matrix = nx.adjacency_matrix(graph).todense()

  return graph, torch.tensor(adjacency_matrix)

@Registry.register_helper('random_float', 'initialization')
def random_float(shape, params):
  &quot;&quot;&quot;
    Generates a `Tensor` of the given shape, with random floating point
    numbers in between and including the lower and upper limit.
  &quot;&quot;&quot;

  max = params['upper_limit'] + 1 # include max itself.
  min = params['lower_limit']

  # torch.rand returns a tensor of the given shape, filled with
  # floating point numbers in the range (0, 1]. multiplying the
  # tensor by max - min and adding the min value ensure it's
  # within the given range.
  tens = (max - min) * torch.rand(shape) + min

  return tens

@Registry.register_helper('random_int', 'initialization')
def random_int(shape, params):
  &quot;&quot;&quot;
    Generates a `Tensor` of the given shape, with random integers in
    between and including the lower and upper limit.
  &quot;&quot;&quot;

  max = math.floor(params['upper_limit'] + 1) # include max itself.
  min = math.floor(params['lower_limit'])

  # torch.randint returns the tensor we need.
  tens = torch.randint(min, max, shape)

  return tens
</code></pre>
<h3 id="registry-and-runner">Registry and Runner</h3>
<p>The code that <strong>executes</strong> the simulation uses the AgentTorch <code>Registry</code> and
<code>Runner</code>, like so:</p>
<pre><code class="language-python">config = read_config('config-map.yaml')
metadata = config.get('simulation_metadata')
num_episodes = metadata.get('num_episodes')
num_steps_per_episode = metadata.get('num_steps_per_episode')
num_substeps_per_step = metadata.get('num_substeps_per_step')
</code></pre>
<p>The registry is stores all the classes and functions used by the model, and
allows the runner to call them as needed when intializing the simulation and
executing the substeps.</p>
<pre><code class="language-python">registry = Registry()
registry.register(read_from_file, 'read_from_file', 'initialization')
registry.register(grid_network, 'grid', key='network')
</code></pre>
<p>The runner intializes and executes the simulation for us. It also returns:</p>
<ul>
<li>a list of the learnable parameters, so we can run optimization functions on
  them and use the optimized values for the next episode.</li>
<li>the trajectory of the state so far, so we can visualize the state using
  libraries like <code>matplotlib</code>.</li>
</ul>
<pre><code class="language-python">runner = Runner(config, registry)
</code></pre>
<p><small> The source code for the visualizer used in the following block is given
in the next section. </small></p>
<pre><code class="language-python">runner.init()

for episode in range(num_episodes):
  runner.step(num_steps_per_episode)

  final_states = list(filter(
    lambda x: x['current_substep'] == str(num_substeps_per_step - 1),
    runner.state_trajectory[-1]
  ))
  visualizer = Plot(metadata.get('max_x'), metadata.get('max_y'))
  visualizer.plot(final_states)
</code></pre>
<p><img alt="png" src="../../media/predator-prey_47_0.png" /></p>
<p><img alt="png" src="../../media/predator-prey_47_1.png" /></p>
<p><img alt="png" src="../../media/predator-prey_47_2.png" /></p>
<p><img alt="png" src="../../media/predator-prey_47_3.png" /></p>
<p><img alt="png" src="../../media/predator-prey_47_4.png" /></p>
<p><img alt="png" src="../../media/predator-prey_47_5.png" /></p>
<h2 id="visualization">Visualization</h2>
<p>You can plot the simulation in different ways. In this notebook, two such
methods are demonstrated; the X-Y grid, and the OpenStreetMap plot.</p>
<pre><code class="language-python"># display the gifs

from IPython.display import HTML

HTML(&quot;&quot;&quot;
    &lt;table&gt;
    &lt;tr&gt;&lt;td&gt;
    &lt;video alt=&quot;grid&quot; autoplay&gt;
        &lt;source src=&quot;../predator-prey.mp4&quot; type=&quot;video/mp4&quot;&gt;
    &lt;/video&gt;
    &lt;/td&gt;&lt;td&gt;
    &lt;img src=&quot;../predator-prey.gif&quot; alt=&quot;map&quot; /&gt;
    &lt;/td&gt;&lt;/tr&gt;
    &lt;/table&gt;
&quot;&quot;&quot;)
</code></pre>
<table>
<tr><td>
<video alt="grid" autoplay>
    <source src="../predator-prey.mp4" type="video/mp4">
</video>
</td><td>
<img src="../predator-prey.gif" alt="map" />
</td></tr>
</table>

<pre><code class="language-python"># render the map

from IPython.display import display, clear_output

import time
import matplotlib
import matplotlib.pyplot as plotter
import matplotlib.patches as patcher
import contextily as ctx

%matplotlib inline

class Plot:
  def __init__(self, max_x, max_y):
    # intialize the scatterplot
    self.figure, self.axes = None, None
    self.prey_scatter, self.pred_scatter = None, None
    self.max_x, self.max_y = max_x, max_y

    plotter.xlim(0, max_x - 1)
    plotter.ylim(0, max_y - 1)
    self.i = 0

  def update(self, state):
    graph = state['network']['agent_agent']['predator_prey']['graph']
    self.coords = [(node[1]['x'], node[1]['y']) for node in graph.nodes(data=True)]
    self.coords.sort(key=lambda x: -(x[0] + x[1]))

    self.figure, self.axes = ox.plot_graph(graph, edge_linewidth=0.3, edge_color='gray', show=False, close=False)
    ctx.add_basemap(self.axes, crs=graph.graph['crs'], source=ctx.providers.OpenStreetMap.Mapnik)
    self.axes.set_axis_off()

    # get coordinates of all the entities to show.
    prey = state['agents']['prey']
    pred = state['agents']['predator']
    grass = state['objects']['grass']

    # agar energy &gt; 0 hai... toh zinda ho tum!
    alive_prey = prey['coordinates'][torch.where(prey['energy'] &gt; 0)[0]]
    alive_pred = pred['coordinates'][torch.where(pred['energy'] &gt; 0)[0]]
    # show only fully grown grass, which can be eaten.
    grown_grass = grass['coordinates'][torch.where(grass['growth_stage'] == 1)[0]]

    alive_prey_x, alive_prey_y = np.array([
      self.coords[(self.max_y * pos[0]) + pos[1]] for pos in alive_prey
    ]).T
    alive_pred_x, alive_pred_y = np.array([
      self.coords[(self.max_y * pos[0]) + pos[1]] for pos in alive_pred
    ]).T

    # show prey in dark blue and predators in maroon.
    self.axes.scatter(alive_prey_x, alive_prey_y, c='#0d52bd', marker='.')
    self.axes.scatter(alive_pred_x, alive_pred_y, c='#8b0000', marker='.')

    # increment the step count.
    self.i += 1
    # show the current step count, and the population counts.
    self.axes.set_title('Predator-Prey Simulation #' + str(self.i), loc='left')
    self.axes.legend(handles=[
      patcher.Patch(color='#fc46aa', label=str(self.i) + ' step'),
      patcher.Patch(color='#0d52bd', label=str(len(alive_prey)) + ' prey'),
      patcher.Patch(color='#8b0000', label=str(len(alive_pred)) + ' predators'),
      # patcher.Patch(color='#d1ffbd', label=str(len(grown_grass)) + ' grass')
    ])

    display(plotter.gcf())
    clear_output(wait=True)
    time.sleep(1)

  def plot(self, states):
    # plot each state, one-by-one
    for state in states:
      self.update(state)

    clear_output(wait=True)
</code></pre>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    
      
      
      <script id="__config" type="application/json">{"annotate": null, "base": "../..", "features": [], "search": "../../assets/javascripts/workers/search.2c215733.min.js", "tags": null, "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}, "version": null}</script>
    
    
      <script src="../../assets/javascripts/bundle.79ae519e.min.js"></script>
      
    
  </body>
</html>